<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StegoChannel Interactive Demo</title>
  <style>
/* ============================================
   CSS RESET & VARIABLES
   ============================================ */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Colors */
  --bg-primary: #1a1a2e;
  --bg-secondary: #16213e;
  --bg-tertiary: #0f3460;
  --bg-card: #1f2940;
  --text-primary: #eaeaea;
  --text-secondary: #a0a0a0;
  --text-muted: #6a6a8a;
  --accent-signal: #00d4aa;
  --accent-cover: #6c757d;
  --accent-warning: #ffc107;
  --accent-error: #dc3545;
  --accent-info: #17a2b8;
  --accent-highlight: #7c3aed;
  --border-color: #2d3748;

  /* Spacing */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* Typography */
  --font-mono: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

  /* Layout */
  --header-height: 60px;
  --inspector-width: 380px;
}

body {
  font-family: var(--font-sans);
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  line-height: 1.5;
}

/* ============================================
   HEADER
   ============================================ */
.header {
  height: var(--header-height);
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--spacing-lg);
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
}

.header-left {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.logo {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--accent-signal);
}

.beacon-status {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--bg-tertiary);
  border-radius: 6px;
  font-size: 0.85rem;
  font-family: var(--font-mono);
}

.beacon-mode {
  color: var(--accent-info);
  text-transform: uppercase;
  font-size: 0.7rem;
  font-weight: 600;
}

.epoch-display {
  color: var(--text-secondary);
}

.header-center {
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
}

.mode-toggle {
  display: flex;
  background: var(--bg-tertiary);
  border-radius: 6px;
  overflow: hidden;
}

.mode-btn {
  padding: var(--spacing-xs) var(--spacing-md);
  border: none;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 0.85rem;
  transition: all 0.2s;
}

.mode-btn.active {
  background: var(--accent-highlight);
  color: white;
}

.mode-btn:hover:not(.active) {
  background: var(--bg-card);
}

.speed-control {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.speed-slider {
  width: 80px;
  accent-color: var(--accent-highlight);
}

.header-right {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.key-display {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  color: var(--text-muted);
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--bg-card);
  border-radius: 4px;
}

.btn {
  padding: var(--spacing-xs) var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-card);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.85rem;
  transition: all 0.2s;
}

.btn:hover {
  background: var(--bg-tertiary);
  border-color: var(--accent-highlight);
}

.btn-primary {
  background: var(--accent-highlight);
  border-color: var(--accent-highlight);
}

.btn-primary:hover {
  background: #6d28d9;
}

.btn-success {
  background: var(--accent-signal);
  border-color: var(--accent-signal);
  color: var(--bg-primary);
}

.btn-icon {
  width: 36px;
  height: 36px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ============================================
   MAIN LAYOUT
   ============================================ */
.main-container {
  display: flex;
  margin-top: var(--header-height);
  height: calc(100vh - var(--header-height));
}

.split-view {
  display: flex;
  flex: 1;
  transition: margin-right 0.3s ease;
}

.split-view.inspector-open {
  margin-right: var(--inspector-width);
}

.panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
  overflow: hidden;
}

.panel:last-child {
  border-right: none;
}

.panel-header {
  padding: var(--spacing-md);
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.panel-title {
  font-size: 1rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.panel-title .icon {
  font-size: 1.2rem;
}

.panel-content {
  flex: 1;
  overflow-y: auto;
  padding: var(--spacing-md);
}

/* ============================================
   SENDER VIEW
   ============================================ */
.message-input-section {
  background: var(--bg-card);
  border-radius: 8px;
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
}

.message-input-section h3 {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.message-input {
  width: 100%;
  padding: var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 1rem;
  resize: none;
}

.message-input:focus {
  outline: none;
  border-color: var(--accent-highlight);
}

.binary-display {
  font-family: var(--font-mono);
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-top: var(--spacing-sm);
  word-break: break-all;
  background: var(--bg-primary);
  padding: var(--spacing-sm);
  border-radius: 4px;
}

.progress-section {
  background: var(--bg-card);
  border-radius: 8px;
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
}

.progress-bar-container {
  background: var(--bg-primary);
  border-radius: 4px;
  height: 8px;
  overflow: hidden;
  margin: var(--spacing-sm) 0;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-signal), var(--accent-highlight));
  transition: width 0.3s ease;
}

.progress-stats {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.post-counter {
  display: flex;
  gap: var(--spacing-lg);
  margin-top: var(--spacing-sm);
}

.counter-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
}

.counter-item .signal {
  color: var(--accent-signal);
}

.counter-item .cover {
  color: var(--accent-cover);
}

.draft-section {
  background: var(--bg-card);
  border-radius: 8px;
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
}

.draft-textarea {
  width: 100%;
  min-height: 80px;
  padding: var(--spacing-sm);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 0.95rem;
  resize: vertical;
}

.draft-textarea:focus {
  outline: none;
  border-color: var(--accent-highlight);
}

.media-toggle {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-sm);
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.media-toggle input {
  accent-color: var(--accent-highlight);
}

.feature-display {
  background: var(--bg-primary);
  border-radius: 6px;
  padding: var(--spacing-md);
  margin-top: var(--spacing-md);
  font-family: var(--font-mono);
  font-size: 0.85rem;
}

.feature-row {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid var(--border-color);
}

.feature-row:last-child {
  border-bottom: none;
}

.feature-label {
  color: var(--text-secondary);
}

.feature-value {
  color: var(--text-primary);
}

.feature-bit {
  display: inline-block;
  width: 20px;
  height: 20px;
  line-height: 20px;
  text-align: center;
  border-radius: 4px;
  font-weight: 600;
  margin-left: var(--spacing-xs);
}

.feature-bit.bit-0 {
  background: var(--accent-cover);
  color: white;
}

.feature-bit.bit-1 {
  background: var(--accent-signal);
  color: var(--bg-primary);
}

.match-display {
  margin-top: var(--spacing-md);
  padding: var(--spacing-sm);
  border-radius: 6px;
  text-align: center;
  font-weight: 600;
}

.match-display.match {
  background: rgba(0, 212, 170, 0.2);
  color: var(--accent-signal);
  border: 1px solid var(--accent-signal);
}

.match-display.no-match {
  background: rgba(108, 117, 125, 0.2);
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
}

.draft-actions {
  display: flex;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

.suggestions {
  background: var(--bg-tertiary);
  border-radius: 6px;
  padding: var(--spacing-sm) var(--spacing-md);
  margin-top: var(--spacing-md);
  font-size: 0.85rem;
}

.suggestion-title {
  color: var(--accent-warning);
  font-weight: 600;
  margin-bottom: var(--spacing-xs);
}

.suggestion-match {
  color: var(--accent-signal);
  font-weight: 500;
}

.suggestion-match kbd {
  background: var(--bg-tertiary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.8rem;
  margin-left: 8px;
}

.suggestion-header {
  display: flex;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-sm);
  font-family: var(--font-mono);
  font-size: 0.85rem;
}

.bits-needed {
  color: var(--accent-warning);
}

.bits-current {
  color: var(--text-secondary);
}

.bits-diff {
  color: var(--accent-info);
  margin-left: auto;
}

.suggestion-paths {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.suggestion-item {
  color: var(--text-secondary);
  padding: var(--spacing-xs) 0;
}

.suggestion-item.easiest {
  color: var(--accent-signal);
}

.easiest-badge {
  background: var(--accent-signal);
  color: var(--bg-primary);
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 0.7rem;
  font-weight: 600;
  margin-right: 4px;
}

/* Draft Buffer Panel */
.draft-buffer-panel {
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: var(--spacing-md);
  margin-top: var(--spacing-md);
}

.draft-buffer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
  font-weight: 500;
}

.draft-match-alert {
  background: var(--accent-signal);
  color: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.8rem;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.draft-buffer-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.draft-item {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--bg-secondary);
  border-radius: 4px;
  font-size: 0.85rem;
}

.draft-item.matches {
  border: 1px solid var(--accent-signal);
  background: rgba(0, 212, 170, 0.1);
}

.draft-bits {
  font-family: var(--font-mono);
  color: var(--accent-info);
  min-width: 60px;
}

.draft-preview {
  flex: 1;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.use-draft-btn {
  background: var(--accent-signal);
  color: var(--bg-primary);
  border: none;
  padding: 2px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 500;
}

.delete-draft-btn {
  background: transparent;
  color: var(--text-muted);
  border: none;
  padding: 2px 6px;
  cursor: pointer;
}

/* Keyboard Help Overlay */
.keyboard-help-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.keyboard-help-content {
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: var(--spacing-lg);
  max-width: 360px;
}

.keyboard-help-content h3 {
  margin-bottom: var(--spacing-md);
  color: var(--accent-signal);
}

.shortcut-grid {
  display: grid;
  gap: var(--spacing-sm);
}

.shortcut {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.shortcut kbd {
  background: var(--bg-tertiary);
  padding: 4px 8px;
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.85rem;
  min-width: 90px;
  text-align: center;
}

/* Keyboard Hint Button */
.keyboard-hint {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 8px;
  cursor: pointer;
  color: var(--text-secondary);
}

.keyboard-hint:hover {
  border-color: var(--accent-signal);
  color: var(--accent-signal);
}

.keyboard-hint kbd {
  font-family: var(--font-mono);
}

/* ============================================
   RECEIVER VIEW
   ============================================ */
.decode-status {
  background: var(--bg-card);
  border-radius: 8px;
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
}

.decode-status h3 {
  font-size: 0.85rem;
  color: var(--text-secondary);
  margin-bottom: var(--spacing-sm);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.frame-display {
  font-family: var(--font-mono);
  font-size: 0.85rem;
  background: var(--bg-primary);
  border-radius: 6px;
  padding: var(--spacing-md);
}

.frame-section {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) 0;
}

.frame-label {
  color: var(--text-muted);
  min-width: 60px;
}

.frame-value {
  color: var(--text-primary);
}

.frame-value.pending {
  color: var(--text-muted);
  font-style: italic;
}

.frame-value.complete {
  color: var(--accent-signal);
}

.frame-value.error {
  color: var(--accent-error);
}

.bit-buffer {
  margin-top: var(--spacing-md);
  padding: var(--spacing-sm);
  background: var(--bg-secondary);
  border-radius: 4px;
  font-family: var(--font-mono);
  font-size: 0.8rem;
  word-break: break-all;
}

.bit-buffer .byte {
  display: inline-block;
  margin-right: var(--spacing-sm);
  padding: 2px 4px;
  background: var(--bg-tertiary);
  border-radius: 2px;
}

.decoded-message {
  margin-top: var(--spacing-md);
  padding: var(--spacing-md);
  background: rgba(0, 212, 170, 0.1);
  border: 1px solid var(--accent-signal);
  border-radius: 6px;
  font-size: 1.1rem;
  text-align: center;
}

.decoded-message.partial {
  background: var(--bg-secondary);
  border-color: var(--border-color);
}

.waiting-status {
  text-align: center;
  color: var(--text-muted);
  padding: var(--spacing-md);
  font-style: italic;
}

/* ============================================
   FEED / TIMELINE
   ============================================ */
.feed {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.post-card {
  background: var(--bg-card);
  border-radius: 8px;
  padding: var(--spacing-md);
  border: 1px solid var(--border-color);
  transition: all 0.2s;
  cursor: pointer;
}

.post-card:hover {
  border-color: var(--accent-highlight);
}

.post-card.signal {
  border-left: 3px solid var(--accent-signal);
}

.post-card.cover {
  opacity: 0.7;
}

.post-card.selected {
  border-color: var(--accent-highlight);
  box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.3);
}

.post-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-sm);
}

.post-author {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: var(--bg-tertiary);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 0.85rem;
}

.author-name {
  font-weight: 600;
}

.post-meta {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  font-size: 0.8rem;
  color: var(--text-muted);
}

.signal-badge {
  background: var(--accent-signal);
  color: var(--bg-primary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
}

.cover-badge {
  background: var(--accent-cover);
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
}

.post-content {
  color: var(--text-primary);
  line-height: 1.5;
}

.post-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: var(--spacing-sm);
  padding-top: var(--spacing-sm);
  border-top: 1px solid var(--border-color);
  font-size: 0.8rem;
}

.extracted-bits {
  font-family: var(--font-mono);
  color: var(--accent-signal);
  background: rgba(0, 212, 170, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
}

.media-indicator {
  color: var(--accent-info);
}

.post-highlight {
  animation: highlight 1s ease-out;
}

@keyframes highlight {
  0% {
    background: rgba(0, 212, 170, 0.3);
  }
  100% {
    background: var(--bg-card);
  }
}

/* ============================================
   INSPECTOR PANEL
   ============================================ */
.inspector {
  position: fixed;
  top: var(--header-height);
  right: 0;
  bottom: 0;
  width: var(--inspector-width);
  background: var(--bg-secondary);
  border-left: 1px solid var(--border-color);
  transform: translateX(100%);
  transition: transform 0.3s ease;
  display: flex;
  flex-direction: column;
  z-index: 50;
}

.inspector.open {
  transform: translateX(0);
}

.inspector-header {
  padding: var(--spacing-md);
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.inspector-title {
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.inspector-tabs {
  display: flex;
  border-bottom: 1px solid var(--border-color);
}

.inspector-tab {
  flex: 1;
  padding: var(--spacing-sm);
  border: none;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.2s;
}

.inspector-tab.active {
  color: var(--accent-highlight);
  border-bottom: 2px solid var(--accent-highlight);
}

.inspector-tab:hover:not(.active) {
  background: var(--bg-card);
}

.inspector-content {
  flex: 1;
  overflow-y: auto;
  padding: var(--spacing-md);
}

.inspector-section {
  margin-bottom: var(--spacing-lg);
}

.inspector-section h4 {
  font-size: 0.8rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--spacing-sm);
  padding-bottom: var(--spacing-xs);
  border-bottom: 1px solid var(--border-color);
}

.key-chain {
  font-family: var(--font-mono);
  font-size: 0.8rem;
}

.key-row {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
}

.key-label {
  color: var(--text-secondary);
}

.key-value {
  color: var(--accent-info);
  cursor: pointer;
}

.key-value:hover {
  text-decoration: underline;
}

.threshold-display {
  background: var(--bg-card);
  padding: var(--spacing-md);
  border-radius: 6px;
  text-align: center;
  margin-top: var(--spacing-sm);
}

.threshold-value {
  font-size: 1.5rem;
  font-family: var(--font-mono);
  color: var(--accent-signal);
}

.threshold-explanation {
  font-size: 0.8rem;
  color: var(--text-muted);
  margin-top: var(--spacing-xs);
}

.hash-analysis {
  background: var(--bg-card);
  border-radius: 6px;
  padding: var(--spacing-md);
  font-family: var(--font-mono);
  font-size: 0.8rem;
}

.hash-row {
  display: flex;
  justify-content: space-between;
  padding: var(--spacing-xs) 0;
  border-bottom: 1px solid var(--border-color);
}

.hash-row:last-child {
  border-bottom: none;
}

.hash-result {
  font-weight: 600;
  padding: var(--spacing-sm);
  border-radius: 4px;
  text-align: center;
  margin-top: var(--spacing-sm);
}

.hash-result.signal {
  background: rgba(0, 212, 170, 0.2);
  color: var(--accent-signal);
}

.hash-result.cover {
  background: rgba(108, 117, 125, 0.2);
  color: var(--accent-cover);
}

.event-log {
  max-height: 300px;
  overflow-y: auto;
  background: var(--bg-card);
  border-radius: 6px;
  padding: var(--spacing-sm);
}

.event-item {
  display: flex;
  gap: var(--spacing-sm);
  padding: var(--spacing-xs) 0;
  font-size: 0.8rem;
  border-bottom: 1px solid var(--border-color);
}

.event-item:last-child {
  border-bottom: none;
}

.event-time {
  color: var(--text-muted);
  font-family: var(--font-mono);
  min-width: 70px;
}

.event-type {
  font-weight: 600;
  min-width: 60px;
}

.event-type.signal {
  color: var(--accent-signal);
}

.event-type.epoch {
  color: var(--accent-info);
}

.event-type.decode {
  color: var(--accent-warning);
}

.event-message {
  color: var(--text-secondary);
}

/* ============================================
   SCENARIO MODAL
   ============================================ */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 200;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s;
}

.modal-overlay.open {
  opacity: 1;
  visibility: visible;
}

.modal {
  background: var(--bg-secondary);
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
  max-height: 80vh;
  overflow: hidden;
  transform: scale(0.9);
  transition: transform 0.3s;
}

.modal-overlay.open .modal {
  transform: scale(1);
}

.modal-header {
  padding: var(--spacing-lg);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  font-size: 1.25rem;
}

.modal-close {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 1.5rem;
  line-height: 1;
}

.modal-content {
  padding: var(--spacing-lg);
  overflow-y: auto;
  max-height: calc(80vh - 120px);
}

.scenario-list {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.scenario-item {
  padding: var(--spacing-md);
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}

.scenario-item:hover {
  border-color: var(--accent-highlight);
  background: var(--bg-tertiary);
}

.scenario-item h3 {
  font-size: 1rem;
  margin-bottom: var(--spacing-xs);
}

.scenario-item p {
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.scenario-item .duration {
  font-size: 0.8rem;
  color: var(--accent-info);
  margin-top: var(--spacing-xs);
}

/* ============================================
   STEP MODE OVERLAY
   ============================================ */
.step-overlay {
  position: fixed;
  bottom: var(--spacing-lg);
  left: 50%;
  transform: translateX(-50%);
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: var(--spacing-md) var(--spacing-lg);
  display: none;
  align-items: center;
  gap: var(--spacing-lg);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  z-index: 150;
}

.step-overlay.active {
  display: flex;
}

.step-explanation {
  max-width: 400px;
}

.step-explanation h4 {
  font-size: 0.9rem;
  color: var(--accent-highlight);
  margin-bottom: var(--spacing-xs);
}

.step-explanation p {
  font-size: 0.85rem;
  color: var(--text-secondary);
}

/* ============================================
   RESPONSIVE
   ============================================ */
@media (max-width: 768px) {
  .split-view {
    flex-direction: column;
  }

  .panel {
    border-right: none;
    border-bottom: 1px solid var(--border-color);
  }

  .inspector {
    width: 100%;
    height: 50vh;
    top: auto;
    bottom: 0;
    transform: translateY(100%);
  }

  .inspector.open {
    transform: translateY(0);
  }

  .header-center {
    display: none;
  }
}

/* ============================================
   UTILITIES
   ============================================ */
.hidden {
  display: none !important;
}

.mono {
  font-family: var(--font-mono);
}

.text-signal {
  color: var(--accent-signal);
}

.text-cover {
  color: var(--accent-cover);
}

.text-muted {
  color: var(--text-muted);
}

/* ============================================
   ACCESSIBILITY
   ============================================ */
:focus-visible {
  outline: 2px solid var(--accent-highlight);
  outline-offset: 2px;
}

.skip-link {
  position: absolute;
  top: -100px;
  left: 10px;
  background: var(--accent-highlight);
  color: white;
  padding: 8px 12px;
  z-index: 2000;
  border-radius: 0 0 4px 4px;
  font-weight: 600;
  text-decoration: none;
  transition: top 0.2s;
}

.skip-link:focus {
  top: 0;
}
  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">üîê StegoChannel Demo</div>
      <div class="beacon-status">
        <select id="beaconModeSelect" onchange="changeBeaconMode(this.value)" aria-label="Beacon Mode" style="background: var(--bg-card); color: var(--accent-info); border: 1px solid var(--border-color); border-radius: 4px; padding: 2px 6px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; cursor: pointer;">
          <option value="manual">Manual</option>
          <option value="accelerated">Accelerated</option>
          <option value="fixed">Fixed Seed</option>
        </select>
        <span class="epoch-display">Epoch: <span id="epochNumber">1</span></span>
        <span class="epoch-display">| <span id="beaconValue">a3f2...</span></span>
        <button class="btn" id="nextEpochBtn" onclick="Beacon.nextEpoch()" style="padding: 2px 8px; font-size: 0.75rem;">Next Epoch</button>
      </div>
    </div>

    <div class="header-center">
      <div class="mode-toggle">
        <button class="mode-btn active" id="stepModeBtn" onclick="setMode('step')">Step</button>
        <button class="mode-btn" id="autoModeBtn" onclick="setMode('auto')">Auto</button>
      </div>
      <div class="speed-control" id="speedControl" style="display: none;">
        <span>Speed:</span>
        <input type="range" class="speed-slider" id="speedSlider" min="0.5" max="4" step="0.5" value="1" aria-label="Simulation Speed">
        <span id="speedValue">1x</span>
      </div>
    </div>

    <div class="header-right">
      <div class="key-display" title="Channel Key">Key: <span id="keyDisplay">demo123</span></div>
      <button class="btn" onclick="openAboutModal()">How It Works</button>
      <button class="btn" onclick="openScenarioModal()">Scenarios</button>
      <button class="btn" onclick="resetDemo()">Reset</button>
      <button onclick="toggleKeyboardHelp()" class="keyboard-hint" title="Keyboard shortcuts" aria-label="Keyboard shortcuts"><kbd>?</kbd></button>
      <button class="btn btn-icon" id="inspectorToggle" onclick="toggleInspector()" title="Toggle Inspector (I)" aria-expanded="true" aria-controls="inspector" aria-label="Toggle Inspector">I</button>
    </div>
  </header>

  <!-- Main Container -->
  <main class="main-container" id="main-content">
    <div class="split-view" id="splitView">
      <!-- Sender Panel -->
      <div class="panel" id="senderPanel">
        <div class="panel-header">
          <div class="panel-title">
            <span class="icon" role="img" aria-label="Sender">üì§</span>
            Sender View
          </div>
        </div>
        <div class="panel-content">
          <!-- Message Input -->
          <div class="message-input-section">
            <h3>Message to Transmit</h3>
            <input type="text" class="message-input" id="messageInput" placeholder="Enter your secret message..." value="HELLO" aria-label="Message to transmit">
            <div class="binary-display" id="binaryDisplay" aria-live="polite">
              Binary: 01001000 01000101 01001100 01001100 01001111 (40 bits + frame overhead)
            </div>
          </div>

          <!-- Transmission Progress -->
          <div class="progress-section">
            <h3>Transmission Progress</h3>
            <div class="progress-bar-container">
              <div class="progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
            <div class="progress-stats">
              <span><span id="bitsSent">0</span> / <span id="totalBits">56</span> bits</span>
              <span id="progressPercent">0%</span>
            </div>
            <div class="post-counter">
              <div class="counter-item">
                <span class="signal">‚óè</span> Signal: <span id="signalCount">0</span>
              </div>
              <div class="counter-item">
                <span class="cover">‚óè</span> Cover: <span id="coverCount">0</span>
              </div>
            </div>
          </div>

          <!-- Draft Composition -->
          <div class="draft-section">
            <h3>Compose Draft Post</h3>
            <textarea class="draft-textarea" id="draftTextarea" placeholder="Write your post..." oninput="updateFeatureDisplay()" aria-label="Draft post content"></textarea>
            <label class="media-toggle">
              <input type="checkbox" id="hasMedia" onchange="updateFeatureDisplay()">
              Has media attachment
            </label>

            <!-- Feature Display -->
            <div class="feature-display" id="featureDisplay">
              <div class="feature-row">
                <span class="feature-label">Length</span>
                <span class="feature-value">
                  <span id="lengthValue">0</span> chars | ‚â•50? <span id="lengthCheck">NO</span>
                  <span class="feature-bit bit-0" id="lengthBit">0</span>
                </span>
              </div>
              <div class="feature-row">
                <span class="feature-label">Media</span>
                <span class="feature-value">
                  <span id="mediaValue">NO</span>
                  <span class="feature-bit bit-0" id="mediaBit">0</span>
                </span>
              </div>
              <div class="feature-row">
                <span class="feature-label">Question?</span>
                <span class="feature-value">
                  <span id="questionValue">NO</span>
                  <span class="feature-bit bit-0" id="questionBit">0</span>
                </span>
              </div>
              <div class="feature-row" id="fwordRow" style="display: none;">
                <span class="feature-label">First Word</span>
                <span class="feature-value">
                  <span id="fwordValue">other</span>
                  <span class="feature-bit bit-1" id="fwordHighBit">1</span>
                  <span class="feature-bit bit-1" id="fwordLowBit">1</span>
                </span>
              </div>
              <div class="feature-row">
                <span class="feature-label">Extracted</span>
                <span class="feature-value mono" id="extractedBits">000</span>
              </div>
              <div class="feature-row">
                <span class="feature-label">Needed</span>
                <span class="feature-value mono" id="neededBits">010</span>
              </div>
            </div>

            <div class="match-display no-match" id="matchDisplay">
              ‚úó NO MATCH - This will be a cover post
            </div>

            <div class="suggestions" id="suggestions">
              <div class="suggestion-title">üí° Suggestions</div>
              <div class="suggestion-item" id="suggestionText">Add ~50 characters to set the length bit</div>
            </div>

            <div class="draft-actions">
              <button class="btn btn-success" id="publishBtn" onclick="publishPost()">Publish</button>
              <button class="btn" onclick="publishAsCover()">Publish as Cover</button>
              <button class="btn" onclick="saveToDraftBuffer()">Save (S)</button>
              <button class="btn" onclick="discardDraft()">Discard</button>
            </div>
          </div>

          <!-- Sender's Feed View -->
          <h3 style="margin-bottom: var(--spacing-sm);">Published Posts</h3>
          <div class="feed" id="senderFeed" aria-live="polite">
            <div class="waiting-status">No posts yet. Compose and publish your first post!</div>
          </div>
        </div>
      </div>

      <!-- Receiver Panel -->
      <div class="panel" id="receiverPanel">
        <div class="panel-header">
          <div class="panel-title">
            <span class="icon" role="img" aria-label="Receiver">üì•</span>
            Receiver View
          </div>
        </div>
        <div class="panel-content">
          <!-- Decode Status -->
          <div class="decode-status">
            <h3>Message Decoding</h3>
            <div class="frame-display">
              <div class="frame-section">
                <span class="frame-label">Header:</span>
                <span class="frame-value pending" id="frameHeader">Waiting for version+flags byte...</span>
              </div>
              <div class="frame-section">
                <span class="frame-label">Length:</span>
                <span class="frame-value pending" id="frameLength">--</span>
              </div>
              <div class="frame-section">
                <span class="frame-label">Data:</span>
                <span class="frame-value pending" id="frameData">--</span>
              </div>
              <div class="frame-section">
                <span class="frame-label">MAC:</span>
                <span class="frame-value pending" id="frameMac">--</span>
              </div>
            </div>

            <div class="bit-buffer" id="bitBuffer">
              Accumulated bits: <span id="accumulatedBits">--</span>
            </div>

            <div class="decoded-message partial" id="decodedMessage" aria-live="polite">
              Waiting for signal posts...
            </div>
          </div>

          <!-- Receiver's Feed View -->
          <h3 style="margin-bottom: var(--spacing-sm);">Incoming Feed</h3>
          <div class="feed" id="receiverFeed" aria-live="polite">
            <div class="waiting-status">Monitoring for posts...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Inspector Panel -->
    <aside class="inspector open" id="inspector" aria-label="Protocol Inspector" aria-hidden="false">
      <div class="inspector-header">
        <div class="inspector-title"><span role="img" aria-label="Microscope">üî¨</span> Protocol Inspector</div>
        <button class="modal-close" onclick="toggleInspector()" aria-label="Close Inspector">√ó</button>
      </div>

      <div class="inspector-tabs">
        <button class="inspector-tab active" onclick="switchInspectorTab('keys')">Keys</button>
        <button class="inspector-tab" onclick="switchInspectorTab('hash')">Hash</button>
        <button class="inspector-tab" onclick="switchInspectorTab('log')">Log</button>
        <button class="inspector-tab" onclick="switchInspectorTab('compare')">Compare</button>
      </div>

      <div class="inspector-content">
        <!-- Keys Tab -->
        <div class="inspector-tab-content" id="tab-keys">
          <div class="inspector-section">
            <h4>Key Derivation Chain</h4>
            <div class="key-chain">
              <div class="key-row">
                <span class="key-label">Channel Key:</span>
                <span class="key-value" id="inspectorChannelKey" title="Click to copy">a3f2b7c1...</span>
              </div>
              <div class="key-row">
                <span class="key-label">Beacon Value:</span>
                <span class="key-value" id="inspectorBeacon">e5d4c3b2...</span>
              </div>
              <div class="key-row">
                <span class="key-label">Epoch Key:</span>
                <span class="key-value" id="inspectorEpochKey">7a8b9c0d...</span>
              </div>
            </div>
            <div class="threshold-display">
              <div class="threshold-value" id="inspectorThreshold">0.2473</div>
              <div class="threshold-explanation">
                Posts with hash &lt; <span id="thresholdPercent">24.73%</span> are signals
              </div>
            </div>
          </div>

          <div class="inspector-section">
            <h4>Derivation Formula (SPEC ¬ß5.1)</h4>
            <div style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--text-secondary); background: var(--bg-card); padding: var(--spacing-sm); border-radius: 4px;">
              epoch_key = HKDF-Expand(<br>
              &nbsp;&nbsp;prk: channel_key,<br>
              &nbsp;&nbsp;info: "{beacon_id}:{beacon_value}:stegochannel-v0",<br>
              &nbsp;&nbsp;length: 32<br>
              )<br><br>
              selection = SHA256(epoch_key || post_id)<br>
              is_signal = uint64(hash[0:8]) &lt; threshold
            </div>
          </div>
          <div class="inspector-section" id="testVectorSection">
            <h4>SPEC Test Vector Verification</h4>
            <div id="testVectorResults" style="font-family: var(--font-mono); font-size: 0.8rem; background: var(--bg-card); padding: var(--spacing-sm); border-radius: 4px;">
              Running...
            </div>
          </div>
        </div>

        <!-- Hash Tab -->
        <div class="inspector-tab-content hidden" id="tab-hash">
          <div class="inspector-section">
            <h4>Selected Post Analysis</h4>
            <div class="hash-analysis" id="hashAnalysis">
              <p style="color: var(--text-muted); text-align: center; padding: var(--spacing-md);">
                Click a post to analyze its hash
              </p>
            </div>
          </div>
        </div>

        <!-- Log Tab -->
        <div class="inspector-tab-content hidden" id="tab-log">
          <div class="inspector-section">
            <h4>Protocol Events</h4>
            <div style="margin-bottom: var(--spacing-sm);">
              <select id="logFilter" onchange="filterEventLog()" style="background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85rem;">
                <option value="all">All Events</option>
                <option value="signal">Signals Only</option>
                <option value="epoch">Epochs Only</option>
                <option value="decode">Decodes Only</option>
              </select>
              <button class="btn" style="margin-left: 8px; padding: 4px 8px;" onclick="exportLog()">Export</button>
            </div>
            <div class="event-log" id="eventLog">
              <div class="event-item">
                <span class="event-time">00:00:00</span>
                <span class="event-type epoch">INIT</span>
                <span class="event-message">Demo initialized with default key</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Compare Tab -->
        <div class="inspector-tab-content hidden" id="tab-compare">
          <div class="inspector-section">
            <h4>Observer vs Keyholder View</h4>
            <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: var(--spacing-md);">
              This demonstrates the steganographic principle: without the key,
              signal posts are indistinguishable from cover posts.
            </p>
            <div style="display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-md);">
              <button class="btn" onclick="showObserverView()">üëÅÔ∏è Observer</button>
              <button class="btn btn-primary" onclick="showKeyholderView()">üîë Keyholder</button>
            </div>
            <div id="compareView" style="background: var(--bg-card); border-radius: 6px; padding: var(--spacing-md); font-size: 0.85rem;">
              <p style="color: var(--text-muted);">Keyholder view: Signal/cover posts are distinguished and bits are extracted.</p>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </main>

  <!-- About Modal -->
  <div class="modal-overlay" id="aboutModal" role="dialog" aria-modal="true" aria-labelledby="aboutModalTitle">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h2 id="aboutModalTitle">üîê How StegoChannel Works</h2>
        <button class="modal-close" onclick="closeAboutModal()" aria-label="Close modal">√ó</button>
      </div>
      <div class="modal-content" style="line-height: 1.7;">
        <div style="background: var(--bg-tertiary); border-radius: 8px; padding: var(--spacing-md); margin-bottom: var(--spacing-lg);">
          <p style="font-size: 1.1rem; margin: 0; color: var(--text-primary);">
            <strong>The secret is not in what you say‚Äîit's in which posts you choose to publish.</strong>
          </p>
        </div>

        <h3 style="color: var(--accent-signal); margin-bottom: var(--spacing-sm);">üì§ Sender Side</h3>
        <ol style="color: var(--text-secondary); margin-bottom: var(--spacing-lg); padding-left: var(--spacing-lg);">
          <li style="margin-bottom: var(--spacing-sm);">Enter a secret message (e.g., "HELLO")</li>
          <li style="margin-bottom: var(--spacing-sm);">The message is framed with a header, length, and HMAC authentication tag</li>
          <li style="margin-bottom: var(--spacing-sm);">Write posts naturally‚Äîeach post's <strong>features</strong> encode 3 bits:
            <ul style="margin-top: var(--spacing-xs); list-style: disc; padding-left: var(--spacing-md);">
              <li><strong>Length ‚â• 50 graphemes</strong> ‚Üí bit 1, otherwise ‚Üí bit 0</li>
              <li><strong>Has media</strong> ‚Üí bit 1, otherwise ‚Üí bit 0</li>
              <li><strong>Contains ?</strong> ‚Üí bit 1, otherwise ‚Üí bit 0</li>
            </ul>
          </li>
          <li style="margin-bottom: var(--spacing-sm);">Whether a post is <span style="color: var(--accent-signal); font-weight: 600;">SIGNAL</span> or <span style="color: var(--accent-cover);">COVER</span> is determined by its hash ‚Äî the sender doesn't choose</li>
          <li style="margin-bottom: var(--spacing-sm);">The sender must ensure signal posts have the right feature bits before publishing</li>
        </ol>

        <h3 style="color: var(--accent-info); margin-bottom: var(--spacing-sm);">üì• Receiver Side</h3>
        <ol style="color: var(--text-secondary); margin-bottom: var(--spacing-lg); padding-left: var(--spacing-lg);">
          <li style="margin-bottom: var(--spacing-sm);">Monitor the sender's public feed</li>
          <li style="margin-bottom: var(--spacing-sm);">For each post, compute: <code style="background: var(--bg-card); padding: 2px 6px; border-radius: 3px;">SHA256(epoch_key || post_id)</code></li>
          <li style="margin-bottom: var(--spacing-sm);">If <strong>uint64(hash[0:8]) &lt; threshold</strong> ‚Üí it's a SIGNAL post, extract the 3 feature bits</li>
          <li style="margin-bottom: var(--spacing-sm);">Accumulate bits until the full message frame is reconstructed</li>
          <li style="margin-bottom: var(--spacing-sm);">Verify the HMAC-SHA256 auth tag to confirm authenticity</li>
        </ol>

        <h3 style="color: var(--accent-highlight); margin-bottom: var(--spacing-sm);">üîë The Key Insight</h3>
        <div style="background: var(--bg-card); border-radius: 8px; padding: var(--spacing-md); margin-bottom: var(--spacing-lg);">
          <p style="color: var(--text-secondary); margin: 0;">
            <strong style="color: var(--text-primary);">Without the shared secret key</strong>, an observer cannot determine which posts are signals and which are cover.
            All posts look like normal social media activity. The threshold is derived from the key, so only someone with the key can identify signal posts.
          </p>
        </div>

        <h3 style="color: var(--accent-warning); margin-bottom: var(--spacing-sm);">‚è±Ô∏è Why So Slow?</h3>
        <p style="color: var(--text-secondary); margin-bottom: var(--spacing-lg);">
          At 3 bits per signal post and ~25% signal rate, transmitting "HELLO" (40 bits + frame overhead) requires many signal posts spread over days of normal posting.
          <strong style="color: var(--text-primary);">This slowness is the feature, not a bug</strong>‚Äîit makes the channel indistinguishable from normal activity.
        </p>
        <div style="background: var(--bg-card); border-radius: 8px; padding: var(--spacing-md); margin-bottom: var(--spacing-lg);">
          <p style="color: var(--accent-warning); font-weight: 600; margin-bottom: var(--spacing-xs);">‚ö†Ô∏è Demo Simplifications</p>
          <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0;">
            This demo omits: <strong>Reed-Solomon error correction</strong> (SPEC ¬ß8.4),
            <strong>XChaCha20-Poly1305 encryption</strong> (SPEC ¬ß8.3),
            <strong>sequence number management</strong>, and <strong>epoch grace periods</strong> (SPEC ¬ß4.1).
            Core selection, key derivation, and feature extraction match the full specification.
          </p>
        </div>

        <div style="text-align: center; padding-top: var(--spacing-md); border-top: 1px solid var(--border-color);">
          <p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: var(--spacing-sm);">
            Full protocol specification: <a href="../files/SPEC.md" style="color: var(--accent-info);">SPEC.md</a>
          </p>
          <button class="btn btn-primary" onclick="closeAboutModal()">Got it!</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Scenario Modal -->
  <div class="modal-overlay" id="scenarioModal" role="dialog" aria-modal="true" aria-labelledby="scenarioModalTitle">
    <div class="modal">
      <div class="modal-header">
        <h2 id="scenarioModalTitle">Load Scenario</h2>
        <button class="modal-close" onclick="closeScenarioModal()" aria-label="Close modal">√ó</button>
      </div>
      <div class="modal-content">
        <div class="scenario-list">
          <div class="scenario-item" role="button" tabindex="0" onclick="loadScenario('quick')">
            <h3>‚ö° Quick Demo</h3>
            <p>Short "HI" message to see the protocol in action fast.</p>
            <div class="duration">~90 seconds in auto mode</div>
          </div>
          <div class="scenario-item" role="button" tabindex="0" onclick="loadScenario('educational')">
            <h3>üìö Educational Walkthrough</h3>
            <p>Step-by-step tutorial with explanations at each decision point.</p>
            <div class="duration">~5 minutes in step mode</div>
          </div>
          <div class="scenario-item" role="button" tabindex="0" onclick="loadScenario('epoch')">
            <h3>üîÑ Epoch Boundary</h3>
            <p>Demonstrates key rederivation when epoch changes mid-transmission.</p>
            <div class="duration">~3 minutes</div>
          </div>
          <div class="scenario-item" role="button" tabindex="0" onclick="loadScenario('long')">
            <h3>üìù Long Message</h3>
            <p>Multi-frame transmission showing full message assembly.</p>
            <div class="duration">~10 minutes</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Step Mode Overlay -->
  <div class="step-overlay" id="stepOverlay">
    <div class="step-explanation">
      <h4 id="stepTitle">Post Published</h4>
      <p id="stepDescription">The sender published a new post. The receiver will now check if it's a signal or cover post.</p>
    </div>
    <button class="btn btn-primary" id="nextStepBtn" onclick="nextStep()">Next Step ‚Üí</button>
  </div>

<script>
// ============================================
// STATE MANAGEMENT
// ============================================
const AppState = {
  // Channel configuration
  channelKey: null,
  epochKey: null,
  threshold: 0n, // BigInt ‚Äî computed from rate via Crypto.computeThreshold()
  bitsPerPost: 3, // Default: 3 (len, media, qmark). Extended: 5 (+fword)

  // Beacon state
  beacon: {
    mode: 'manual', // 'manual' | 'accelerated' | 'fixed'
    seed: 'demo123',
    epoch: 1,
    value: null,
    timer: null,
    speed: 1
  },

  // Posts
  posts: [],

  // Draft buffer for auto-matching
  draftBuffer: [],

  // Sender state
  sender: {
    message: 'HELLO',
    messageBits: [],
    bitsSent: 0,
    signalCount: 0,
    coverCount: 0,
    frameOverhead: 16, // header + length + MAC bits simplified
    complete: false
  },

  // Receiver state
  receiver: {
    bitBuffer: [],
    frameState: 'waiting_header',
    decodedMessage: '',
    macVerified: false
  },

  // UI state
  ui: {
    mode: 'step', // 'step' | 'auto'
    inspectorOpen: true,
    selectedPostId: null,
    stepPending: false
  },

  // Event log
  eventLog: []
};

// State change subscribers
const subscribers = [];
function subscribe(fn) {
  subscribers.push(fn);
  return () => subscribers.splice(subscribers.indexOf(fn), 1);
}
function notifyChange() {
  subscribers.forEach(fn => fn(AppState));
}

// ============================================
// CRYPTO UTILITIES (Web Crypto API)
// Implements SPEC.md Sections 3, 5, 6
// ============================================
const Crypto = {
  encoder: new TextEncoder(),
  decoder: new TextDecoder(),

  // SHA-256 hash (SPEC ¬ß3)
  async sha256(data) {
    const buffer = typeof data === 'string' ? this.encoder.encode(data) : data;
    const hash = await crypto.subtle.digest('SHA-256', buffer);
    return new Uint8Array(hash);
  },

  // Internal: full 32-byte HMAC-SHA256 (used by hkdfExpand)
  async hmacFull(key, data) {
    const keyBuffer = typeof key === 'string' ? this.encoder.encode(key) : key;
    const dataBuffer = typeof data === 'string' ? this.encoder.encode(data) : data;
    const cryptoKey = await crypto.subtle.importKey(
      'raw', keyBuffer, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
    );
    const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);
    return new Uint8Array(signature);
  },

  // HMAC-SHA256 truncated to 64 bits (SPEC ¬ß8.2)
  async hmac(key, data) {
    const full = await this.hmacFull(key, data);
    return full.slice(0, 8);
  },

  // HKDF-Expand only (RFC 5869 ¬ß2.3, SPEC ¬ß5.1)
  // Uses channel_key directly as PRK ‚Äî NO Extract step
  async hkdfExpand(prk, info, length = 32) {
    const infoBytes = typeof info === 'string' ? this.encoder.encode(info) : info;
    const hashLen = 32; // SHA-256 output
    const n = Math.ceil(length / hashLen);
    if (n > 255) throw new Error('HKDF-Expand: requested length too long');

    const okm = new Uint8Array(length);
    let previous = new Uint8Array(0);
    let offset = 0;

    for (let i = 1; i <= n; i++) {
      // T(i) = HMAC-SHA256(PRK, T(i-1) || info || byte(i))
      const hmacInput = new Uint8Array(previous.length + infoBytes.length + 1);
      hmacInput.set(previous, 0);
      hmacInput.set(infoBytes, previous.length);
      hmacInput[previous.length + infoBytes.length] = i;

      previous = await this.hmacFull(prk, hmacInput);
      const copyLen = Math.min(hashLen, length - offset);
      okm.set(previous.subarray(0, copyLen), offset);
      offset += copyLen;
    }
    return okm;
  },

  // Convert first 8 bytes of hash to BigInt uint64 BE (SPEC ¬ß6)
  hashToUint64(hash) {
    const view = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);
    return view.getBigUint64(0, false); // big-endian
  },

  // Compute selection threshold from rate (SPEC ¬ß6.1)
  // threshold = floor(rate * (2^64 - 1)) using pure bigint arithmetic
  computeThreshold(rate = 0.25) {
    const maxUint64 = 0xFFFFFFFFFFFFFFFFn;
    const precision = 1_000_000_000n;
    const numerator = BigInt(Math.round(rate * 1_000_000_000));
    return (maxUint64 * numerator) / precision;
  },

  // Hex encoding
  toHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
  },

  fromHex(hex) {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return bytes;
  },

  // Concatenate Uint8Arrays
  concat(...arrays) {
    const total = arrays.reduce((sum, a) => sum + a.length, 0);
    const result = new Uint8Array(total);
    let offset = 0;
    for (const arr of arrays) { result.set(arr, offset); offset += arr.length; }
    return result;
  },

  // Deterministic PRNG from seed (for demo beacon simulation only)
  seededRandom(seed) {
    let state = 0;
    for (let i = 0; i < seed.length; i++) {
      state = ((state << 5) - state + seed.charCodeAt(i)) | 0;
    }
    return function() {
      state = (state * 1103515245 + 12345) | 0;
      return (state >>> 16) / 65536;
    };
  }
};

// ============================================
// PROTOCOL IMPLEMENTATION
// Implements SPEC.md Sections 6, 7, 8
// ============================================
const Protocol = {
  // Normalize text per SPEC ¬ß7.4: NFC + whitespace collapse + trim
  normalizeText(text) {
    return text.normalize('NFC').replace(/\s+/g, ' ').trim();
  },

  // Count grapheme clusters per SPEC ¬ß7.3 (UAX #29)
  countGraphemes(text) {
    try {
      const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
      return [...segmenter.segment(text)].length;
    } catch {
      return text.length; // Fallback for older browsers
    }
  },

  // Extract features from post content (SPEC ¬ß7)
  // Default: 3 bits (len, media, qmark). Extended: +2 bits (fword)
  extractFeatures(content, hasMedia) {
    const normalized = this.normalizeText(content);
    const graphemeCount = this.countGraphemes(normalized);
    const lengthBit = graphemeCount >= 50 ? 1 : 0;
    const mediaBit = hasMedia ? 1 : 0;
    const questionBit = normalized.includes('?') ? 1 : 0;

    // Extended features (fword) ‚Äî available but not default
    const fwordBits = this.extractFirstWordBits(normalized);
    const fwordHigh = (fwordBits >> 1) & 1;
    const fwordLow = fwordBits & 1;

    const bitsPerPost = AppState.bitsPerPost || 3;
    const bitsString = bitsPerPost === 5
      ? `${lengthBit}${mediaBit}${questionBit}${fwordHigh}${fwordLow}`
      : `${lengthBit}${mediaBit}${questionBit}`;

    return {
      graphemeCount,
      rawLength: content.length,
      lengthBit,
      hasMedia,
      mediaBit,
      hasQuestion: normalized.includes('?'),
      questionBit,
      fwordCategory: fwordBits,
      fwordHigh,
      fwordLow,
      bitsString,
      bitsPerPost
    };
  },

  // Extract first word category bits (2 bits) ‚Äî SPEC ¬ß7.2
  extractFirstWordBits(text) {
    const PRONOUNS = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
      'you', 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself',
      'she', 'her', 'hers', 'herself', 'it', 'its', 'itself', 'they', 'them', 'their',
      'theirs', 'themselves', 'who', 'whom', 'whose', 'what', 'which'];
    const ARTICLES = ['a', 'an', 'the', 'this', 'that', 'these', 'those', 'some', 'any',
      'no', 'every', 'each', 'either', 'neither', 'another', 'such'];
    const VERBS = ['is', 'are', 'was', 'were', 'be', 'been', 'being', 'am', 'have', 'has',
      'had', 'having', 'do', 'does', 'did', 'doing', 'will', 'would', 'shall', 'should',
      'can', 'could', 'may', 'might', 'must', 'go', 'goes', 'went', 'going', 'gone',
      'get', 'gets', 'got', 'getting', 'make', 'makes', 'made', 'making', 'see', 'sees',
      'saw', 'seeing', 'seen', 'know', 'knows', 'knew', 'knowing', 'known', 'think',
      'thinks', 'thought', 'thinking'];

    const trimmed = text.trim();
    const match = trimmed.match(/^[a-zA-Z]+/);
    if (!match) return 0b11;

    const firstWord = match[0].toLowerCase();
    if (PRONOUNS.includes(firstWord)) return 0b00;
    if (ARTICLES.includes(firstWord)) return 0b01;
    if (VERBS.includes(firstWord)) return 0b10;
    return 0b11;
  },

  // Check if post is a signal post (SPEC ¬ß6)
  // selection_hash = SHA256(epoch_key || UTF8(post_id))
  // is_signal = uint64_be(hash[0:8]) < threshold
  async isSignal(postId, epochKey, threshold) {
    const postIdBytes = Crypto.encoder.encode(postId);
    const input = Crypto.concat(epochKey, postIdBytes);
    const hash = await Crypto.sha256(input);
    const selectionValue = Crypto.hashToUint64(hash);
    return {
      isSignal: selectionValue < threshold,
      hash: Crypto.toHex(hash),
      selectionValue,
      threshold
    };
  },

  // Convert message to bits (UTF-8 byte-level)
  messageToBits(message) {
    const bytes = Crypto.encoder.encode(message);
    const bits = [];
    for (const byte of bytes) {
      for (let i = 7; i >= 0; i--) {
        bits.push((byte >> i) & 1);
      }
    }
    return bits;
  },

  // Convert bits to message (UTF-8 byte-level)
  bitsToMessage(bits) {
    const bytes = [];
    for (let i = 0; i + 7 < bits.length; i += 8) {
      let byte = 0;
      for (let j = 0; j < 8; j++) {
        byte = (byte << 1) | bits[i + j];
      }
      bytes.push(byte);
    }
    try {
      return Crypto.decoder.decode(new Uint8Array(bytes));
    } catch {
      // Fallback for incomplete/invalid UTF-8
      return bytes.filter(b => b >= 32 && b < 127).map(b => String.fromCharCode(b)).join('');
    }
  },

  // Get next required bits from message
  getNextRequiredBits(messageBits, bitsSent) {
    const bitsPerPost = AppState.bitsPerPost || 3;
    const bits = [];
    for (let i = 0; i < bitsPerPost && bitsSent + i < messageBits.length; i++) {
      bits.push(messageBits[bitsSent + i]);
    }
    while (bits.length < bitsPerPost) bits.push(0);
    return bits.join('');
  },

  // Build message frame (SPEC ¬ß8.1)
  // Format: [version:4|flags:4] [length_hi:8] [length_lo:8] [payload...] [auth_tag:64]
  // ‚ö†Ô∏è Simplified: no Reed-Solomon ECC, no encryption
  buildFrame(message) {
    const payload = Crypto.encoder.encode(message);
    const headerByte = 0x00; // version=0, flags=0 (plaintext, no compression)
    const lengthInBits = payload.length * 8;
    const lengthHigh = (lengthInBits >> 8) & 0xFF;
    const lengthLow = lengthInBits & 0xFF;

    const frameWithoutAuth = new Uint8Array(3 + payload.length);
    frameWithoutAuth[0] = headerByte;
    frameWithoutAuth[1] = lengthHigh;
    frameWithoutAuth[2] = lengthLow;
    frameWithoutAuth.set(payload, 3);
    return frameWithoutAuth;
  },

  // Build frame with HMAC auth tag (SPEC ¬ß8.2)
  async buildFrameWithAuth(message, epochKey) {
    const frameWithoutAuth = this.buildFrame(message);
    const authTag = await Crypto.hmac(epochKey, frameWithoutAuth); // 8 bytes
    const completeFrame = new Uint8Array(frameWithoutAuth.length + authTag.length);
    completeFrame.set(frameWithoutAuth);
    completeFrame.set(authTag, frameWithoutAuth.length);
    return completeFrame;
  },

  // Convert frame to bits (MSB-first)
  frameToBits(frame) {
    const bits = [];
    for (const byte of frame) {
      for (let i = 7; i >= 0; i--) {
        bits.push((byte >> i) & 1);
      }
    }
    return bits;
  }
};

// ============================================
// BEACON MANAGEMENT
// ============================================
const Beacon = {
  async init() {
    AppState.channelKey = await Crypto.sha256(AppState.beacon.seed);
    // Threshold is constant for a given rate ‚Äî not derived from epoch key (SPEC ¬ß6.1)
    AppState.threshold = Crypto.computeThreshold(0.25);
    await this.updateEpoch();
    logEvent('epoch', `Initialized with seed "${AppState.beacon.seed}"`);
  },

  async updateEpoch() {
    // Generate beacon value from seed + epoch (simulated for demo)
    const beaconInput = `${AppState.beacon.seed}-epoch-${AppState.beacon.epoch}`;
    AppState.beacon.value = await Crypto.sha256(beaconInput);

    // Derive epoch key using HKDF-Expand (SPEC ¬ß5.1)
    // info = "beaconId:beaconValue:stegochannel-v0"
    const beaconId = `demo-epoch-${AppState.beacon.epoch}`;
    const beaconValue = Crypto.toHex(AppState.beacon.value);
    const info = `${beaconId}:${beaconValue}:stegochannel-v0`;
    AppState.epochKey = await Crypto.hkdfExpand(AppState.channelKey, info);

    // Update UI
    updateBeaconDisplay();
    updateInspectorKeys();
  },

  async nextEpoch() {
    AppState.beacon.epoch++;
    await this.updateEpoch();
    logEvent('epoch', `Epoch advanced to ${AppState.beacon.epoch}`);
  },

  setMode(mode) {
    AppState.beacon.mode = mode;
    if (AppState.beacon.timer) {
      clearInterval(AppState.beacon.timer);
      AppState.beacon.timer = null;
    }

    if (mode === 'accelerated') {
      const interval = 60000 / AppState.beacon.speed; // 1 minute / speed
      AppState.beacon.timer = setInterval(() => this.nextEpoch(), interval);
    }

    // Update UI
    const select = document.getElementById('beaconModeSelect');
    if (select) select.value = mode;

    // Show/hide Next Epoch button based on mode
    const nextBtn = document.getElementById('nextEpochBtn');
    if (nextBtn) nextBtn.style.display = mode === 'manual' ? 'inline-block' : 'none';

    logEvent('beacon', `Beacon mode changed to ${mode.toUpperCase()}`);
  }
};

// Change beacon mode from UI
function changeBeaconMode(mode) {
  Beacon.setMode(mode);
}

// ============================================
// POST MANAGEMENT
// ============================================
let postIdCounter = 0;

async function createPost(content, hasMedia) {
  const postId = `post-${++postIdCounter}`;
  const post = {
    id: postId,
    author: 'Alice',
    content,
    hasMedia,
    timestamp: Date.now(),
    epoch: AppState.beacon.epoch,
    features: Protocol.extractFeatures(content, hasMedia)
  };

  // Determine signal/cover from hash ‚Äî sender does NOT choose (SPEC ¬ß6)
  const signalCheck = await Protocol.isSignal(postId, AppState.epochKey, AppState.threshold);
  post.hash = signalCheck.hash;
  post.selectionValue = signalCheck.selectionValue;
  post.isSignal = signalCheck.isSignal;

  AppState.posts.unshift(post);

  const bitsPerPost = AppState.bitsPerPost || 3;

  if (post.isSignal) {
    AppState.sender.signalCount++;
    // Extract bits from signal post features
    const bitsToAdd = Math.min(bitsPerPost, AppState.sender.messageBits.length - AppState.sender.bitsSent);
    AppState.sender.bitsSent += bitsToAdd;

    // Add bits to receiver's buffer
    const extractedBits = post.features.bitsString.split('').map(Number).slice(0, bitsToAdd);
    AppState.receiver.bitBuffer.push(...extractedBits);

    logEvent('signal', `Signal post: bits=${post.features.bitsString.slice(0, bitsToAdd)} [${postId}]`);
  } else {
    AppState.sender.coverCount++;
    logEvent('cover', `Cover post [${postId}]`);
  }

  // Check for message completion
  if (AppState.sender.bitsSent >= AppState.sender.messageBits.length && !AppState.sender.complete) {
    AppState.sender.complete = true;
    AppState.receiver.decodedMessage = Protocol.bitsToMessage(AppState.receiver.bitBuffer);
    AppState.receiver.frameState = 'complete';
    logEvent('decode', `Message decoded: "${AppState.receiver.decodedMessage}"`);
  }

  updateUI();
  return post;
}

// ============================================
// UI UPDATE FUNCTIONS
// ============================================
function updateUI() {
  updateProgressDisplay();
  updateReceiverDisplay();
  renderFeeds();
  updateDraftBufferUI();
  notifyChange();
}

function updateBeaconDisplay() {
  document.getElementById('epochNumber').textContent = AppState.beacon.epoch;
  document.getElementById('beaconValue').textContent =
    AppState.beacon.value ? Crypto.toHex(AppState.beacon.value).slice(0, 8) + '...' : '...';
}

function updateProgressDisplay() {
  const { bitsSent, messageBits, signalCount, coverCount, complete } = AppState.sender;
  const totalBits = messageBits.length;
  const percent = totalBits > 0 ? Math.round((bitsSent / totalBits) * 100) : 0;

  document.getElementById('progressBar').style.width = `${percent}%`;
  document.getElementById('bitsSent').textContent = bitsSent;
  document.getElementById('totalBits').textContent = totalBits;
  document.getElementById('progressPercent').textContent = `${percent}%`;
  document.getElementById('signalCount').textContent = signalCount;
  document.getElementById('coverCount').textContent = coverCount;

  if (complete) {
    document.getElementById('progressBar').style.background = 'var(--accent-signal)';
  }
}

function updateReceiverDisplay() {
  const { bitBuffer, frameState, decodedMessage } = AppState.receiver;

  // Update bit buffer display
  const bufferStr = bitBuffer.length > 0
    ? bitBuffer.join('').match(/.{1,8}/g)?.map(b => `<span class="byte">${b}</span>`).join(' ') || '--'
    : '--';
  document.getElementById('accumulatedBits').innerHTML = bufferStr;

  // Update frame display ‚Äî SPEC ¬ß8.1 format:
  // [version:4|flags:4] [length_hi:8] [length_lo:8] [payload...] [auth_tag:64]
  const headerComplete = bitBuffer.length >= 8;  // 1 byte = version + flags
  const lengthComplete = bitBuffer.length >= 24;  // + 2 bytes = 16-bit length

  document.getElementById('frameHeader').textContent = headerComplete
    ? `v${(parseInt(bitBuffer.slice(0,4).join(''),2))}, flags=0x${parseInt(bitBuffer.slice(4,8).join(''),2).toString(16)} ‚úì`
    : `Waiting... (${Math.min(bitBuffer.length, 8)}/8 bits)`;
  document.getElementById('frameHeader').className = `frame-value ${headerComplete ? 'complete' : 'pending'}`;

  if (headerComplete) {
    if (lengthComplete) {
      const lengthBits = bitBuffer.slice(8, 24);
      const lengthInBits = parseInt(lengthBits.join(''), 2);
      document.getElementById('frameLength').textContent = `${lengthInBits} bits (${Math.ceil(lengthInBits/8)} bytes)`;
      document.getElementById('frameLength').className = 'frame-value complete';
    } else {
      document.getElementById('frameLength').textContent = `(${Math.max(0, bitBuffer.length - 8)}/16 bits)`;
    }
  }

  // Update decoded message
  const msgEl = document.getElementById('decodedMessage');
  if (frameState === 'complete') {
    msgEl.textContent = `‚úì Decoded: "${decodedMessage}"`;
    msgEl.className = 'decoded-message';
  } else if (bitBuffer.length > 0) {
    const partial = Protocol.bitsToMessage(bitBuffer);
    msgEl.textContent = partial ? `Decoding: "${partial}..."` : `Receiving bits... (${bitBuffer.length})`;
    msgEl.className = 'decoded-message partial';
  } else {
    msgEl.textContent = 'Waiting for signal posts...';
    msgEl.className = 'decoded-message partial';
  }
}

function updateFeatureDisplay() {
  const content = document.getElementById('draftTextarea').value;
  const hasMedia = document.getElementById('hasMedia').checked;
  const features = Protocol.extractFeatures(content, hasMedia);

  // Update individual features
  document.getElementById('lengthValue').textContent = features.graphemeCount;
  document.getElementById('lengthCheck').textContent = features.lengthBit ? 'YES' : 'NO';
  document.getElementById('lengthBit').textContent = features.lengthBit;
  document.getElementById('lengthBit').className = `feature-bit bit-${features.lengthBit}`;

  document.getElementById('mediaValue').textContent = features.hasMedia ? 'YES' : 'NO';
  document.getElementById('mediaBit').textContent = features.mediaBit;
  document.getElementById('mediaBit').className = `feature-bit bit-${features.mediaBit}`;

  document.getElementById('questionValue').textContent = features.hasQuestion ? 'YES' : 'NO';
  document.getElementById('questionBit').textContent = features.questionBit;
  document.getElementById('questionBit').className = `feature-bit bit-${features.questionBit}`;

  // Update fword display (visible in extended mode)
  const fwordRow = document.getElementById('fwordRow');
  const fwordLabels = ['pronoun', 'article', 'verb', 'other'];
  document.getElementById('fwordValue').textContent = fwordLabels[features.fwordCategory];
  document.getElementById('fwordHighBit').textContent = features.fwordHigh;
  document.getElementById('fwordHighBit').className = `feature-bit bit-${features.fwordHigh}`;
  document.getElementById('fwordLowBit').textContent = features.fwordLow;
  document.getElementById('fwordLowBit').className = `feature-bit bit-${features.fwordLow}`;
  if (fwordRow) fwordRow.style.display = AppState.bitsPerPost === 5 ? '' : 'none';

  document.getElementById('extractedBits').textContent = features.bitsString;

  // Get needed bits
  const neededBits = Protocol.getNextRequiredBits(AppState.sender.messageBits, AppState.sender.bitsSent);
  document.getElementById('neededBits').textContent = neededBits;

  // Check match ‚Äî bits match AND post would need to be a signal post
  const isMatch = features.bitsString === neededBits;
  const matchEl = document.getElementById('matchDisplay');
  if (isMatch) {
    matchEl.textContent = '‚úì BITS MATCH - If this post is selected as signal, the message advances!';
    matchEl.className = 'match-display match';
  } else {
    matchEl.textContent = '‚úó BITS DON\'T MATCH - Adjust before publishing as signal';
    matchEl.className = 'match-display no-match';
  }

  // Update suggestions
  updateSuggestions(features, neededBits);
}

function updateSuggestions(features, neededBits) {
  const needed = neededBits.split('').map(Number);
  const current = features.bitsString.split('').map(Number);
  const suggestionsEl = document.getElementById('suggestions');

  if (features.bitsString === neededBits) {
    suggestionsEl.style.display = 'block';
    suggestionsEl.innerHTML = '<div class="suggestion-match">Bits match! Publish when ready. <kbd>Ctrl+Enter</kbd></div>';
    return;
  }

  const paths = [];
  if (needed[0] !== current[0]) {
    const diff = needed[0] === 1 ? Math.max(1, 50 - features.graphemeCount) : features.graphemeCount - 49;
    paths.push({ action: needed[0] === 1 ? `Add ~${diff} chars (need ‚â•50 graphemes)` : `Shorten to <50 graphemes`, effort: Math.abs(diff), type: 'len' });
  }
  if (needed[1] !== current[1]) {
    paths.push({ action: needed[1] === 1 ? 'Check "Has media"' : 'Uncheck "Has media"', effort: 1, type: 'media' });
  }
  if (needed[2] !== current[2]) {
    paths.push({ action: needed[2] === 1 ? 'Add a ? somewhere' : 'Remove the ?', effort: 1, type: 'qmark' });
  }
  // Extended mode (5-bit) ‚Äî fword suggestions
  if (AppState.bitsPerPost === 5 && needed.length > 3 && (needed[3] !== current[3] || needed[4] !== current[4])) {
    const neededCat = (needed[3] << 1) | needed[4];
    const cats = ['pronoun (I, we, you...)', 'article (a, the, this...)', 'verb (is, have, do...)', 'other word'];
    paths.push({ action: `Start with ${cats[neededCat]}`, effort: 3, type: 'fword' });
  }

  paths.sort((a, b) => a.effort - b.effort);

  suggestionsEl.style.display = 'block';
  suggestionsEl.innerHTML = `
    <div class="suggestion-header">
      <span class="bits-needed">Need: <code>${neededBits}</code></span>
      <span class="bits-current">Have: <code>${features.bitsString}</code></span>
      <span class="bits-diff">${paths.length} change${paths.length !== 1 ? 's' : ''}</span>
    </div>
    <div class="suggestion-paths">
      ${paths.map((p, i) => `<div class="suggestion-item ${i === 0 ? 'easiest' : ''}">${i === 0 ? '<span class="easiest-badge">Easiest</span>' : ''} ${p.action}</div>`).join('')}
    </div>`;
}

function renderFeeds() {
  const senderFeed = document.getElementById('senderFeed');
  const receiverFeed = document.getElementById('receiverFeed');

  if (AppState.posts.length === 0) {
    senderFeed.innerHTML = '<div class="waiting-status">No posts yet. Compose and publish your first post!</div>';
    receiverFeed.innerHTML = '<div class="waiting-status">Monitoring for posts...</div>';
    return;
  }

    const renderPost = (post, showSignalInfo) => {
    const isSelected = AppState.ui.selectedPostId === post.id;
    return `
      <div class="post-card ${post.isSignal ? 'signal' : 'cover'} ${isSelected ? 'selected' : ''}"
           role="button" tabindex="0"
           onclick="selectPost('${post.id}')">
        <div class="post-header">

          <div class="post-author">
            <div class="avatar">${post.author[0]}</div>
            <span class="author-name">${post.author}</span>
          </div>
          <div class="post-meta">
            ${showSignalInfo ? (post.isSignal
              ? '<span class="signal-badge">SIGNAL</span>'
              : '<span class="cover-badge">COVER</span>') : ''}
            <span>${formatTime(post.timestamp)}</span>
          </div>
        </div>
        <div class="post-content">${escapeHtml(post.content)}</div>
        <div class="post-footer">
          ${post.isSignal && showSignalInfo
            ? `<span class="extracted-bits">bits: ${post.features.bitsString}</span>`
            : '<span></span>'}
          ${post.hasMedia ? '<span class="media-indicator" role="img" aria-label="Has media">üì∑</span>' : ''}
        </div>
      </div>
    `;
  };

  senderFeed.innerHTML = AppState.posts.map(p => renderPost(p, true)).join('');
  receiverFeed.innerHTML = AppState.posts.map(p => renderPost(p, true)).join('');
}

function updateInspectorKeys() {
  document.getElementById('inspectorChannelKey').textContent =
    AppState.channelKey ? Crypto.toHex(AppState.channelKey).slice(0, 8) + '...' : '...';
  document.getElementById('inspectorBeacon').textContent =
    AppState.beacon.value ? Crypto.toHex(AppState.beacon.value).slice(0, 8) + '...' : '...';
  document.getElementById('inspectorEpochKey').textContent =
    AppState.epochKey ? Crypto.toHex(AppState.epochKey).slice(0, 8) + '...' : '...';
  // Threshold is BigInt ‚Äî display as hex and percentage
  const thresholdHex = '0x' + AppState.threshold.toString(16).padStart(16, '0').slice(0, 8) + '...';
  const thresholdPercent = Number(AppState.threshold * 10000n / 0xFFFFFFFFFFFFFFFFn) / 100;
  document.getElementById('inspectorThreshold').textContent = thresholdHex;
  document.getElementById('thresholdPercent').textContent = thresholdPercent.toFixed(2) + '%';
}

// ============================================
// USER ACTIONS
// ============================================
async function publishPost() {
  const content = document.getElementById('draftTextarea').value.trim();
  if (!content) return;

  const hasMedia = document.getElementById('hasMedia').checked;
  const features = Protocol.extractFeatures(content, hasMedia);
  const neededBits = Protocol.getNextRequiredBits(AppState.sender.messageBits, AppState.sender.bitsSent);

  // Signal/cover is determined by hash, not by feature matching
  const post = await createPost(content, hasMedia);
  const bitsMatch = features.bitsString === neededBits;

  // Clear draft
  document.getElementById('draftTextarea').value = '';
  document.getElementById('hasMedia').checked = false;
  updateFeatureDisplay();

  // Step mode handling
  if (AppState.ui.mode === 'step') {
    if (post.isSignal && bitsMatch) {
      showStepExplanation('Signal Post Published',
        `This post's hash selected it as SIGNAL. Its bits "${features.bitsString}" match the needed bits ‚Äî message advances!`);
    } else if (post.isSignal && !bitsMatch) {
      showStepExplanation('Signal Post ‚Äî Wrong Bits!',
        `This post IS a signal post (hash < threshold), but its bits "${features.bitsString}" don't match needed "${neededBits}". The wrong bits were extracted ‚Äî message may be corrupted.`);
    } else {
      showStepExplanation('Cover Post Published',
        `Hash ‚â• threshold ‚Üí cover post. Bits don't matter ‚Äî this post is invisible to the receiver.`);
    }
  }
}

async function publishAsCover() {
  // In the real protocol, you can't force a post to be cover ‚Äî it's hash-determined.
  // But for the demo, publishing as cover means: publish and accept whatever the hash says.
  // The post might actually be a signal post! This demonstrates the protocol's nature.
  const content = document.getElementById('draftTextarea').value.trim();
  if (!content) return;

  const hasMedia = document.getElementById('hasMedia').checked;
  await createPost(content, hasMedia);

  document.getElementById('draftTextarea').value = '';
  document.getElementById('hasMedia').checked = false;
  updateFeatureDisplay();
}

function discardDraft() {
  document.getElementById('draftTextarea').value = '';
  document.getElementById('hasMedia').checked = false;
  updateFeatureDisplay();
}

function saveToDraftBuffer() {
  const content = document.getElementById('draftTextarea').value.trim();
  if (!content) return;
  const hasMedia = document.getElementById('hasMedia').checked;
  const features = Protocol.extractFeatures(content, hasMedia);
  if (AppState.draftBuffer.some(d => d.content === content)) return;
  AppState.draftBuffer.push({ content, hasMedia, features, savedAt: Date.now() });
  logEvent('draft', `Saved draft with bits ${features.bitsString}`);
  document.getElementById('draftTextarea').value = '';
  document.getElementById('hasMedia').checked = false;
  updateFeatureDisplay();
  updateDraftBufferUI();
}

function useDraftFromBuffer(index) {
  const draft = AppState.draftBuffer[index];
  AppState.draftBuffer.splice(index, 1);
  document.getElementById('draftTextarea').value = draft.content;
  document.getElementById('hasMedia').checked = draft.hasMedia;
  updateFeatureDisplay();
  updateDraftBufferUI();
  logEvent('draft', 'Loaded matching draft from buffer');
}

function updateDraftBufferUI() {
  let bufferEl = document.getElementById('draftBufferPanel');
  if (!bufferEl) {
    const composeArea = document.querySelector('.draft-section');
    if (composeArea) {
      bufferEl = document.createElement('div');
      bufferEl.id = 'draftBufferPanel';
      bufferEl.className = 'draft-buffer-panel';
      composeArea.parentNode.insertBefore(bufferEl, composeArea.nextSibling);
    }
  }
  if (!bufferEl || AppState.draftBuffer.length === 0) {
    if (bufferEl) bufferEl.style.display = 'none';
    return;
  }
  const neededBits = Protocol.getNextRequiredBits(AppState.sender.messageBits, AppState.sender.bitsSent);
  bufferEl.style.display = 'block';
  bufferEl.innerHTML = `
    <div class="draft-buffer-header">Draft Buffer (${AppState.draftBuffer.length})
      ${AppState.draftBuffer.some(d => d.features.bitsString === neededBits) ? '<span class="draft-match-alert">Match!</span>' : ''}
    </div>
    <div class="draft-buffer-list">
      ${AppState.draftBuffer.map((d, i) => `
        <div class="draft-item ${d.features.bitsString === neededBits ? 'matches' : ''}">
          <span class="draft-bits">${d.features.bitsString}</span>
          <span class="draft-preview">${d.content.slice(0, 25)}${d.content.length > 25 ? '...' : ''}</span>
          ${d.features.bitsString === neededBits
            ? `<button onclick="useDraftFromBuffer(${i})" class="use-draft-btn">Use</button>`
            : `<button onclick="AppState.draftBuffer.splice(${i}, 1); updateDraftBufferUI();" class="delete-draft-btn">x</button>`}
        </div>`).join('')}
    </div>`;
}

function selectPost(postId) {
  AppState.ui.selectedPostId = postId;
  renderFeeds();

  const post = AppState.posts.find(p => p.id === postId);
  if (post) {
    updateHashAnalysis(post);
  }
}

function updateHashAnalysis(post) {
  const selValHex = post.selectionValue !== undefined ? '0x' + post.selectionValue.toString(16).padStart(16, '0') : '‚Äî';
  const threshHex = '0x' + AppState.threshold.toString(16).padStart(16, '0');
  const html = `
    <div class="hash-row">
      <span>Input:</span>
      <span style="color: var(--text-muted); word-break: break-all;">epoch_key || "${post.id}"</span>
    </div>
    <div class="hash-row">
      <span>SHA-256:</span>
      <span style="color: var(--accent-info);">${post.hash.slice(0, 16)}...</span>
    </div>
    <div class="hash-row">
      <span>Selection (uint64):</span>
      <span style="word-break: break-all;">${selValHex}</span>
    </div>
    <div class="hash-row">
      <span>Threshold:</span>
      <span>${threshHex}</span>
    </div>
    <div class="hash-result ${post.isSignal ? 'signal' : 'cover'}">
      ${post.isSignal ? 'value < threshold ‚Üí SIGNAL' : 'value ‚â• threshold ‚Üí COVER'}
    </div>
    <div style="margin-top: var(--spacing-md);">
      <h5 style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: var(--spacing-xs);">Features (${post.features.bitsPerPost} bits):</h5>
      <div class="hash-row">
        <span>Length (${post.features.graphemeCount} graphemes):</span>
        <span>${post.features.lengthBit}</span>
      </div>
      <div class="hash-row">
        <span>Media:</span>
        <span>${post.features.mediaBit}</span>
      </div>
      <div class="hash-row">
        <span>Question:</span>
        <span>${post.features.questionBit}</span>
      </div>
      <div class="hash-row" style="font-weight: bold;">
        <span>Bits:</span>
        <span style="color: var(--accent-signal);">${post.features.bitsString}</span>
      </div>
    </div>
  `;
  document.getElementById('hashAnalysis').innerHTML = html;

  // Switch to hash tab
  switchInspectorTab('hash');
}

// ============================================
// MODE CONTROLS
// ============================================
function setMode(mode) {
  AppState.ui.mode = mode;

  document.getElementById('stepModeBtn').classList.toggle('active', mode === 'step');
  document.getElementById('autoModeBtn').classList.toggle('active', mode === 'auto');
  document.getElementById('speedControl').style.display = mode === 'auto' ? 'flex' : 'none';

  if (mode === 'step') {
    hideStepOverlay();
  }
}

function showStepExplanation(title, description) {
  document.getElementById('stepTitle').textContent = title;
  document.getElementById('stepDescription').textContent = description;
  document.getElementById('stepOverlay').classList.add('active');
  AppState.ui.stepPending = true;
}

function hideStepOverlay() {
  document.getElementById('stepOverlay').classList.remove('active');
  AppState.ui.stepPending = false;
}

function nextStep() {
  hideStepOverlay();
}

// ============================================
// INSPECTOR CONTROLS
// ============================================
function toggleInspector() {
  AppState.ui.inspectorOpen = !AppState.ui.inspectorOpen;
  const inspector = document.getElementById('inspector');
  const btn = document.getElementById('inspectorToggle');
  
  inspector.classList.toggle('open', AppState.ui.inspectorOpen);
  inspector.setAttribute('aria-hidden', !AppState.ui.inspectorOpen);
  
  if (btn) {
    btn.setAttribute('aria-expanded', AppState.ui.inspectorOpen);
  }
  
  document.getElementById('splitView').classList.toggle('inspector-open', AppState.ui.inspectorOpen);
}

function switchInspectorTab(tab) {
  document.querySelectorAll('.inspector-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.inspector-tab-content').forEach(c => c.classList.add('hidden'));

  document.querySelector(`.inspector-tab:nth-child(${['keys', 'hash', 'log', 'compare'].indexOf(tab) + 1})`).classList.add('active');
  document.getElementById(`tab-${tab}`).classList.remove('hidden');
}

function showObserverView() {
  document.getElementById('compareView').innerHTML = `
    <p style="color: var(--text-muted); margin-bottom: var(--spacing-sm);">
      <strong>Observer view:</strong> Without the channel key, all posts look identical.
      There's no way to distinguish signal posts from cover posts.
    </p>
    <div style="opacity: 0.7;">
      ${AppState.posts.slice(0, 3).map(p => `
        <div style="padding: 8px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 4px;">
          <strong>${p.author}</strong>: ${p.content.slice(0, 40)}...
        </div>
      `).join('') || '<p style="color: var(--text-muted);">No posts yet</p>'}
    </div>
  `;
}

function showKeyholderView() {
  document.getElementById('compareView').innerHTML = `
    <p style="color: var(--text-muted); margin-bottom: var(--spacing-sm);">
      <strong>Keyholder view:</strong> With the channel key, signal posts are identified
      and message bits are extracted.
    </p>
    <div>
      ${AppState.posts.slice(0, 3).map(p => `
        <div style="padding: 8px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 4px; border-left: 3px solid ${p.isSignal ? 'var(--accent-signal)' : 'var(--accent-cover)'};">
          <strong>${p.author}</strong>: ${p.content.slice(0, 40)}...
          <span style="float: right; color: ${p.isSignal ? 'var(--accent-signal)' : 'var(--accent-cover)'};">
            ${p.isSignal ? `[${p.features.bitsString}]` : '(cover)'}
          </span>
        </div>
      `).join('') || '<p style="color: var(--text-muted);">No posts yet</p>'}
    </div>
  `;
}

// ============================================
// EVENT LOG
// ============================================
function logEvent(type, message) {
  const event = {
    time: new Date().toLocaleTimeString(),
    type,
    message
  };
  AppState.eventLog.unshift(event);
  renderEventLog();
}

function renderEventLog() {
  const filter = document.getElementById('logFilter')?.value || 'all';
  const events = filter === 'all'
    ? AppState.eventLog
    : AppState.eventLog.filter(e => e.type === filter);

  document.getElementById('eventLog').innerHTML = events.slice(0, 50).map(e => `
    <div class="event-item">
      <span class="event-time">${e.time}</span>
      <span class="event-type ${e.type}">${e.type.toUpperCase()}</span>
      <span class="event-message">${e.message}</span>
    </div>
  `).join('');
}

function filterEventLog() {
  renderEventLog();
}

function exportLog() {
  const blob = new Blob([JSON.stringify(AppState.eventLog, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'stego-demo-log.json';
  a.click();
  URL.revokeObjectURL(url);
}

// ============================================
// SCENARIOS
// ============================================
// ============================================
// ABOUT MODAL
// ============================================
function openAboutModal() {
  document.getElementById('aboutModal').classList.add('open');
}

function closeAboutModal() {
  document.getElementById('aboutModal').classList.remove('open');
}

// ============================================
// SCENARIOS
// ============================================
function openScenarioModal() {
  document.getElementById('scenarioModal').classList.add('open');
}

function closeScenarioModal() {
  document.getElementById('scenarioModal').classList.remove('open');
}

async function loadScenario(scenario) {
  closeScenarioModal();
  await resetDemo();

  switch (scenario) {
    case 'quick':
      document.getElementById('messageInput').value = 'HI';
      await initMessage('HI');
      setMode('auto');
      break;

    case 'educational':
      document.getElementById('messageInput').value = 'OK';
      await initMessage('OK');
      setMode('step');
      showStepExplanation(
        'Educational Walkthrough',
        'This walkthrough will guide you through transmitting a secret message. ' +
        'Watch how posts are classified as signal or cover based on their hash.'
      );
      break;

    case 'epoch':
      document.getElementById('messageInput').value = 'TEST';
      await initMessage('TEST');
      // Will trigger epoch change mid-transmission
      setTimeout(() => Beacon.nextEpoch(), 30000);
      break;

    case 'long':
      document.getElementById('messageInput').value = 'HELLO WORLD';
      await initMessage('HELLO WORLD');
      break;
  }

  logEvent('scenario', `Loaded scenario: ${scenario}`);
}

// ============================================
// RESET & INIT
// ============================================
async function resetDemo() {
  // Reset state
  AppState.posts = [];
  AppState.draftBuffer = [];
  AppState.sender.bitsSent = 0;
  AppState.sender.signalCount = 0;
  AppState.sender.coverCount = 0;
  AppState.sender.complete = false;
  AppState.receiver.bitBuffer = [];
  AppState.receiver.frameState = 'waiting_header';
  AppState.receiver.decodedMessage = '';
  AppState.beacon.epoch = 1;
  AppState.eventLog = [];
  postIdCounter = 0;

  await Beacon.init();
  await initMessage(document.getElementById('messageInput').value || 'HELLO');

  // Re-verify test vectors after reset
  const testResults = await TestVectors.runAll();
  TestVectors.render(testResults);

  updateUI();
  updateFeatureDisplay();
  logEvent('reset', 'Demo reset');
}

async function initMessage(message) {
  AppState.sender.message = message;
  AppState.sender.messageBits = Protocol.messageToBits(message);

  // Update binary display
  const binaryStr = AppState.sender.messageBits
    .join('')
    .match(/.{1,8}/g)
    ?.join(' ') || '';
  document.getElementById('binaryDisplay').textContent =
    `Binary: ${binaryStr} (${AppState.sender.messageBits.length} bits)`;

  updateFeatureDisplay();
}

// ============================================
// UTILITIES
// ============================================
function formatTime(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Accessibility: Click handler for role="button"
  if ((e.key === 'Enter' || e.key === ' ') && e.target.getAttribute('role') === 'button') {
    e.preventDefault();
    e.target.click();
    return;
  }

  if (e.key === 'Escape') {
    closeAboutModal();
    closeScenarioModal();
    hideStepOverlay();
    const help = document.getElementById('keyboardHelp');
    if (help) help.remove();
    return;
  }
  const inInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    publishPost();
    return;
  }
  if (inInput) return;
  switch (e.key.toLowerCase()) {
    case 'i': toggleInspector(); break;
    case 'p': publishPost(); break;
    case 'c': publishAsCover(); break;
    case 's': saveToDraftBuffer(); break;
    case 'd': discardDraft(); break;
    case 'n': document.getElementById('draftTextarea')?.focus(); break;
    case 'e': advanceEpoch(); break;
    case '?': toggleKeyboardHelp(); break;
  }
});

function advanceEpoch() {
  Beacon.nextEpoch();
}

function toggleKeyboardHelp() {
  let helpEl = document.getElementById('keyboardHelp');
  if (helpEl) {
    helpEl.remove();
    return;
  }
  helpEl = document.createElement('div');
  helpEl.id = 'keyboardHelp';
  helpEl.className = 'keyboard-help-overlay';
  helpEl.setAttribute('role', 'dialog');
  helpEl.setAttribute('aria-modal', 'true');
  helpEl.setAttribute('aria-label', 'Keyboard Shortcuts');
  helpEl.innerHTML = `
    <div class="keyboard-help-content">
      <h3>Keyboard Shortcuts</h3>
      <div class="shortcut-grid">
        <div class="shortcut"><kbd>Ctrl+Enter</kbd> Publish signal</div>
        <div class="shortcut"><kbd>P</kbd> Publish draft</div>
        <div class="shortcut"><kbd>C</kbd> Publish as cover</div>
        <div class="shortcut"><kbd>S</kbd> Save to buffer</div>
        <div class="shortcut"><kbd>D</kbd> Discard draft</div>
        <div class="shortcut"><kbd>N</kbd> New draft</div>
        <div class="shortcut"><kbd>E</kbd> Advance epoch</div>
        <div class="shortcut"><kbd>I</kbd> Toggle inspector</div>
        <div class="shortcut"><kbd>?</kbd> This help</div>
        <div class="shortcut"><kbd>Esc</kbd> Close</div>
      </div>
    </div>`;
  helpEl.onclick = (e) => {
    if (e.target === helpEl) helpEl.remove();
  };
  document.body.appendChild(helpEl);
}

// Message input change
document.getElementById('messageInput')?.addEventListener('change', async (e) => {
  await initMessage(e.target.value);
});

// Speed slider
document.getElementById('speedSlider')?.addEventListener('input', (e) => {
  const speed = parseFloat(e.target.value);
  AppState.beacon.speed = speed;
  document.getElementById('speedValue').textContent = `${speed}x`;
});

// ============================================
// SPEC TEST VECTOR VERIFICATION (¬ß13)
// Runs on load to ensure crypto correctness
// ============================================
const TestVectors = {
  async runAll() {
    const results = [];

    // ¬ß13.1: Epoch key derivation
    // channel_key = 0x00...01 (32 bytes), info = "date:2025-02-01:stegochannel-v0"
    const channelKey = new Uint8Array(32);
    channelKey[31] = 1;
    const epochKey = await Crypto.hkdfExpand(channelKey, 'date:2025-02-01:stegochannel-v0');
    const epochKeyHex = Crypto.toHex(epochKey);
    results.push({
      name: '¬ß13.1 Epoch Key',
      pass: epochKeyHex === 'a317acc97f878f4098b4a1bb58570b06e41aa36615070d1ca8b3486cf2fbc3b3',
      expected: 'a317acc9...',
      got: epochKeyHex.slice(0, 8) + '...'
    });

    // ¬ß13.2: Selection hash for post_id "3jxyz123abc"
    const postIdBytes = Crypto.encoder.encode('3jxyz123abc');
    const selInput = Crypto.concat(epochKey, postIdBytes);
    const selHash = await Crypto.sha256(selInput);
    const selHashHex = Crypto.toHex(selHash);
    results.push({
      name: '¬ß13.2 Selection Hash',
      pass: selHashHex.startsWith('780d5f2b'),
      expected: '780d5f2b...',
      got: selHashHex.slice(0, 8) + '...'
    });

    // ¬ß13.2: Threshold at rate=0.25
    const threshold = Crypto.computeThreshold(0.25);
    results.push({
      name: '¬ß13.2 Threshold',
      pass: threshold === 4611686018427387903n,
      expected: '0x3fffffffffffffff',
      got: '0x' + threshold.toString(16)
    });

    // ¬ß13.5: Auth tag for "Hi" frame
    // frame_without_auth = [0x00, 0x00, 0x10, 0x48, 0x69]
    const frameWithoutAuth = new Uint8Array([0x00, 0x00, 0x10, 0x48, 0x69]);
    const authTag = await Crypto.hmac(epochKey, frameWithoutAuth);
    const authTagHex = Crypto.toHex(authTag);
    results.push({
      name: '¬ß13.5 Auth Tag',
      pass: authTagHex === '638125722a26a07b',
      expected: '638125722a26a07b',
      got: authTagHex
    });

    return results;
  },

  render(results) {
    const el = document.getElementById('testVectorResults');
    if (!el) return;
    el.innerHTML = results.map(r =>
      `<div style="padding: 2px 0; color: ${r.pass ? 'var(--accent-signal)' : 'var(--accent-error)'};">` +
      `${r.pass ? '‚úì' : '‚úó'} ${r.name}: ${r.pass ? r.got : `expected ${r.expected}, got ${r.got}`}</div>`
    ).join('');

    const allPass = results.every(r => r.pass);
    console.log(`SPEC test vectors: ${allPass ? 'ALL PASS ‚úì' : 'FAILURES DETECTED ‚úó'}`, results);
    if (!allPass) logEvent('error', 'SPEC test vector verification FAILED ‚Äî crypto may be incorrect');
  }
};

// ============================================
// INITIALIZATION
// ============================================
async function init() {
  await Beacon.init();
  await initMessage('HELLO');
  updateUI();
  updateFeatureDisplay();

  // Inspector open by default
  AppState.ui.inspectorOpen = true;
  document.getElementById('inspector').classList.add('open');
  document.getElementById('splitView').classList.add('inspector-open');

  // Run SPEC test vector verification
  const testResults = await TestVectors.runAll();
  TestVectors.render(testResults);

  logEvent('init', 'StegoChannel Demo initialized');
  console.log('StegoChannel Interactive Demo loaded');
}

// Start the demo
init();
</script>
</body>
</html>
